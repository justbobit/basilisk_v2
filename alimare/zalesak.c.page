/**
# Time-reversed VOF advection in a vortex

This classical test advects and stretches an initially circular
interface in a non-divergent vortical flow. The flow reverts in time
and the interface should come back to its original position. The
difference between the initial and final shapes is a measure of the
errors accumulated during advection.

We will need the advection solver combined with the VOF advection
scheme. */
// #include "grid/cartesian.h"

#include "utils.h"
#include "distance.h"
#include "tag.h"
#include "advection.h"
#include "vof.h"
#include "../alimare/level_set.h"
#define Pi 3.141592653589793
#define Nb_tour 2
#define T 2*Nb_tour*3.14
#define N_display 1 << 8
// #include "alimare/elementary_body.h"

double NB_width;
int     nb_cell_NB =  1 << 2 ;  // number of cells for the NB

/**
The volume fraction is stored in scalar field `f` which is listed as
an *interface* for the VOF solver. We do not advect any tracer with
the default (diffusive) advection scheme of the advection solver. */

scalar f[], dist[];
scalar * interfaces = {f}, * tracers = {dist};
scalar * level_set = NULL;

int MAXLEVEL;

/**
We center the unit box on the origin and set a maximum timestep of 0.1 */

int main() {


  size (100);
  origin (-15, -25);
  
  /**
  We then run the simulation for different levels of refinement. */

  for (MAXLEVEL = 7; MAXLEVEL <= 8; MAXLEVEL++) {
    init_grid (1 << MAXLEVEL);
    run();
  }
}

/**
We define the levelset function $\phi$ on each vertex of the grid and
compute the corresponding volume fraction field. */

event init (i = 0) {
  DT = T/(1280*Nb_tour);
  NB_width = L0*nb_cell_NB / (1<<MAXLEVEL);

  coord * p = input_xy (fopen ("zalesak.gnu", "r"));

  scalar d[];
  distance (d, p);
  // while (adapt_wavelet ({d}, (double[]){1e-3}, MAXLEVEL+2).nf);


  foreach_vertex()
    dist[] = (d[] + d[-1] + d[0,-1] + d[-1,-1])/4.;
  boundary ({dist});
  face vector s[];
  fractions (dist, f, s);

  foreach_vertex(){
    dist[] = -clamp(dist[], -1.02*NB_width, 1.02*NB_width);
  }
  boundary({dist});
  fprintf (stderr,"N %d %d \n", N, N_display);
  if (1) {
    scalar l[];
    // foreach()
    //   l[] = level;
    // output_ppm (l, file = "levels_init.png", n = 400, min = 0, max = 7);

    foreach()
      l[] = f[];
    output_ppm (l, file = "f_reversed_init.png", n = 800, min = 0, max = 1);

    foreach()
      l[] = dist[];
    output_ppm (l, file = "dist_init.png", n = 800, min = -0.1*NB_width,
     max=0.1*NB_width);
  }


}

event velocity (i++) {

  /**
  This event defines the velocity field.
  
  On trees we first adapt the grid so that the estimated error on
  the volume fraction is smaller than $5\times 10^{-3}$. We limit the
  resolution at `MAXLEVEL` and we only refine the volume fraction field
  `f`. */

#if TREE
  adapt_wavelet ({f,dist}, (double[]){1.e-3, 1.e-3*NB_width}, MAXLEVEL, 
    list= {f,dist});
#endif

  foreach_face(x)
    u.x[] = Pi/3.14*(25-y);

  foreach_face(y)
    u.y[] = Pi/3.14*(x-35);
  boundary ((scalar *){u});
}

/**
At the start and end of the simulation we check the sum, min and max
values of the volume fraction field. The sum must be constant to
within machine precision and the volume fraction should be bounded by
zero and one. */

event logfile (t = {0,T}) {
  stats s = statsf (f);
  fprintf (stderr, "#REZ %f %.12f %.9f %g \n", t, s.sum, s.min, s.max);
  stats s2 = statsf (dist);
  fprintf (stderr, "#REZ %f %.12f %.9f %g\n", t, s2.sum, s2.min, s2.max);
}


/**
To compute the error, we reinitialise field `e` at the end of the
simulation with the initial shape and compute the difference with the
final shape. We output the norms as functions of the maximum
resolution `N`. */

// event field (t = T) {
//   scalar e[], e2[];

//   coord * p = input_xy (fopen ("zalesak.gnu", "r"));

//   scalar d[];
//   distance (d, p);
//   // while (adapt_wavelet ({d}, (double[]){1e-3}, MAXLEVEL+2).nf);


//   foreach_vertex()
//     e2[] = (d[] + d[-1] + d[0,-1] + d[-1,-1])/4.;
//   boundary ({e2});
//   face vector s[];
//   fractions (e2, e, s);

//   foreach_vertex(){
//     e2[] = -clamp(dist[], -1.02*NB_width, 1.02*NB_width);
//   }
//   boundary({dist});

//   foreach(){
//     e[]  -= f[];
//     e2[] -= fabs(dist[])< NB_width/2. ? dist[] : e2[];
//   }
//   norm n  = normf (e);
//   norm n2 = normf (e2);
//   fprintf (stderr, "%d %g %g %g %g %g %g\n", N, n.avg, n.rms, n.max, 
//             n2.avg, n2.rms, n2.max);
// }

#if TREE
event levels (t = {T}) {
  if (N == N_display) {
    scalar l[];
    // foreach()
    //   l[] = level;
    // output_ppm (l, file = "levels.png", n = 400, min = 0, max = 7);

    foreach()
      l[] = f[];
    output_ppm (l, file = "f_reversed.png", n = 800, min = 0, max = 1);

    foreach()
      l[] = dist[];
    output_ppm (l, file = "dist.png", n = 800, min = -0.1*NB_width,
     max=0.1*NB_width);

//     double eps = 1.e-8;
//     foreach(){
//       double norm_grad = 0.;
//       l[] = 1.;
//       if(fabs(dist[])<NB_width){
//         double delt = 0.;
//         l[]         = -10.;
//         if(dist[]>0.){
//           foreach_dimension(){
//             double a = max(0.,(dist[]    - dist[-1,0])/Delta);
//             double b = min(0.,(dist[1,0] - dist[]    )/Delta);
//             delt   += max(powf(a,2.),powf(b,2.));
//           }

//           delt             = max(eps,delt);

//           foreach_dimension(){
//             double a = max(0.,(dist[]    - dist[-1,0])/(delt*Delta));
//             double b = min(0.,(dist[1,0] - dist[]    )/(delt*Delta));
//             norm_grad   += max(powf(a,2.),powf(b,2.));
//           }
//         }
//         else{
//           foreach_dimension(){
//             double a = min(0.,(dist[]    - dist[-1,0])/Delta);
//             double b = max(0.,(dist[1,0] - dist[]    )/Delta);
//             delt   += max(powf(a,2.),powf(b,2.));
//           }

//           delt             = max(eps,delt);

//           foreach_dimension(){
//             double a = min(0.,(dist[]    - dist[-1,0])/(delt*Delta));
//             double b = max(0.,(dist[1,0] - dist[]    )/(delt*Delta));
//             norm_grad   += max(powf(a,2.),powf(b,2.));
//           }
//         }
//         l[] = max( l[], 1.-sqrt(delt) );
//       }
//     }
//     output_ppm (l, file = "grad_dist.png", n = 400);
//     norm n  = normf (l);
//     // fprintf (stderr, "%d %g %g %g \n", N, n.avg, n.rms, n.max);
  }
}

event levels2 (t += T/(100*Nb_tour)) 
{ fprintf(stderr,"%g %g \n",N,N_display );
  if (N == N_display) {
    scalar l[];
    // foreach()
    //   l[] = level;
    // output_ppm (l, file = "levels2.gif", n = 400, min = 0, max = 7);

    foreach()
      l[] = f[];
    output_ppm (l, file = "f_reversed2.gif", n = 800, 
      opt = "--delay 1",min = 0, max = 1);

    foreach()
      l[] = fabs(dist[]) < NB_width ? 1. : 0.;
    output_ppm (l, file = "NB.gif", n = 400, 
      opt = "--delay 1",min = 0, max = 1);

    foreach()
      l[] = dist[];
    output_ppm (l, file = "dist2.gif", n = 400, 
      opt = "--delay 1",min = -0.1*NB_width, max=0.1*NB_width);
  }
}
#endif

event LS_reinitialization(i+=4,last){
  if(i>15){
      // fprintf (stderr, "#REZ %f \n",t);
    LS_reinit2(dist,L0/(1 << MAXLEVEL), 0.9*NB_width,
      1.4*(nb_cell_NB << 1));
  }
}


#if 0
event movie (i += 10)
{
  scalar l[];
  foreach()
    l[] = level;
  output_ppm (l, 1 << MAXLEVEL, file = "level.mp4");
}
#endif

/**
## Results

We use gnuplot (see [reversed.plot]()) to compute the convergence rate
of the error norms with and without adaptation. The convergence rates
are comparable.

![Convergence rates for constant- and adaptive grids.](reversed/plot.png)

The shapes of the interface at $t=0$, $t=T/4$, $t=T/2$, $t=3T/4$ and
$t=T$ are displayed below for both sets of simulations (constant and
adaptive), for $N=128$. The shapes for $t=T/4$ should be identical to
those for $t=3T/4$ and similarly for $t=0$ and $t=T$ (for which we
measure the error). Note that the errors for $t=3T/4$ seem to be much
larger than those for $t=T$.

![Shapes of the interface for $t=0$, $t=T/4$, $t=T/2$, $t=3T/4$ and
$t=T$ for two sets of simulations.](reversed/interface.png) 

![Refinement levels for $t=T/2$ and $N=128$.](reversed/levels.png) */
