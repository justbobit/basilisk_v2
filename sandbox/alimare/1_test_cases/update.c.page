/**
#Double embed boundary calculation

First test case with a double calculation inside and outside of an embedded boundary.
This is based on the example of the Bénard–von Kármán Vortex Street for flow 
around a cylinder at Re=160, I modified the geometry for fun and use a
Zalesak's notched disk. Both fluids have the same properties. We use cs for
the cell fraction in one phase and 1-cs in the other.

At the end of each iteration of the solver we swap the variables, change the fs,
the cs and do a solver iteration on the new set of variables.
We use the centered Navier-Stokes solver, with embedded boundaries and advect
the passive tracer *f*. 

I still have issues regarding the use of the same timestep for both phases. They
hare truly independant. Once this is done I will work on making both phases
fields dependant of one another and then make the boundary movement dependant on
both fields.


![Animation of cs*u.x + (1-cs)*u2.x.](update/movie.mp4)(loop)
*/

#define DOUBLE_EMBED 1

#include "embed.h"
#include "../centered_alex.h"
#include "../level_set.h"
// #include "navier-stokes/perfs.h"
#include "tracer.h"
#include "basic_geom.h"
#include "view.h"

scalar f[];
scalar * tracers = {f};
scalar * level_set = NULL;

face vector muv[];

double t2 = 0;

double geometry(double x, double y, double Radius) {

  coord center_circle, center_rectangle, size_rectangle;
  center_circle.x = 0.;
  center_circle.y = 0.;

  center_rectangle.x = -0.0;
  center_rectangle.y =  -0.5;

  size_rectangle.x = 0.51;
  size_rectangle.y = 1.21; 

  double s = circle (x, y, center_circle, Radius);
  double r = -rectangle (x, y, center_rectangle, size_rectangle);

  double zalesak = -difference (s , r);
  // double zalesak = -s;
  // double zalesak = -r;

  return zalesak;
}

/**
The domain is 4 units long, centered vertically. */

int main() {
  L0 = 4.;
  CFL = 0.1;
  origin (-1.5, -L0/2.);
  N = 512;
  mu = muv;
  run(); 
}

/**
We set a constant viscosity corresponding to a Reynolds number of 160,
based on the cylinder diameter (0.125) and the inflow velocity (1). */

event properties (i++)
{
  foreach_face()
    muv.x[] = fm.x[]*0.125/160.;
}

/**
The fluid is injected on the left boundary with a unit velocity. The
tracer is injected in the lower-half of the left boundary. An outflow
condition is used on the right boundary. */

u.n[left]  = dirichlet(1.);
p[left]    = neumann(0.);
pf[left]   = neumann(0.);
f[left]    = dirichlet(y < 0);

u.n[right] = neumann(0.);
p[right]   = dirichlet(0.);
pf[right]  = dirichlet(0.);

/**
The top and bottom walls are free-slip and the cylinder is no-slip. */

u.n[embed] = fabs(y) > 1.5 ? neumann(0.) : dirichlet(0.);
u.t[embed] = fabs(y) > 1.5 ? neumann(0.) : dirichlet(0.);

event init (t = 0)
{
  // DT = 5.e-4;
  /**
  The domain is the intersection of a channel of width unity and a
  circle of diameter 0.125. */

  vertex scalar phi[];
  foreach_vertex() {
    phi[] = -geometry(x,y,1.);
  }
  boundary ({phi});
  fractions (phi, cs, fs);
  restriction({cs,fs});

  /**
  We set the initial velocity field and set a rotating field inside the notched
  disk. */
  
  foreach(){
    double theta = atan2(y, x), r = sqrt(x*x + y*y);
    u.x[]  = cs[] ? 1.           : r/10.*cos(theta);
    // u2.x[] = cs[] ? r*cos(theta) : 0.;
    u.y[]  = cs[] ? 0. : r/10.*sin(theta);
    // u2.y[] = cs[] ? r*sin(theta) : 0.;
  }
  boundary ((scalar *){u});
  scalar l[];
  foreach()
    l[] = cs[];
  output_ppm (cs, file = "f_init.png", n = 1024);
}

/**
We check the number of iterations of the Poisson and viscous
problems. */

event logfile (i++;t <= 0.1)
  fprintf (stderr, "%d %g %g %g %d %d\n", i, t, t2, dt, mgp.i, mgu.i);
/**
We do save a dump at each t++ (real time t2+=0.5)
*/

/**
I combined the `metric` event from the embed.h and the `init` event of
centered.h in the `LS_reinit`. Here the geometry is a notched disk (inspired by
Zalesak's test case) with growing radius. There is no proper treatment for the
growth of the radius (no physical conditions) and the velocity field is poorly
updated (set to $0$ in the newly covered cells).*/
// event LS_reinitialization(i+=5,last){
//   if(i>1){

//     vertex scalar phi[];
//     foreach_vertex() {
//       phi[] = -geometry(x,y,0.13+0.025*t);
//     }
//     boundary ({phi});
//     fractions (phi, cs, fs);
//     /**
//     We set the velocity field in the covered cells. */
    
//     foreach()
//       u.x[] = cs[] ? cs[] : 0.; 
//     boundary ((scalar *){u});
//     trash ({uf});
//     foreach_face()
//       uf.x[] = fm.x[]*face_value (u.x, 0);
//     boundary ((scalar *){uf});

//     /**
//     We update fluid properties. */

//     event ("properties");

//     dtmax = DT;
//     event ("stability");

//   }
// }

/**
We produce an animation of the tracer field. */

event movies ( i +=6)
{
  scalar omega[];
  vector m[];
  foreach(){
    foreach_dimension()
      m.x[]  = cs[]*u.x[] + (1-cs[])*u2.x[];
  }
  vorticity (m, omega);
  boundary ((scalar *) {m});
  boundary ({omega});
  // output_ppm (omega, file = "vort.gif",linear = true);

  view (fov = 16.642, quat = {0,0,0,1}, tx = -0.0665815, 
    ty = -0.00665815, bg = {1,1,1}, width = 600, height = 600, samples = 1);
  draw_vof("cs");
  squares("m.x",linear = true, min=-1, max = 1);
  save ("movie.mp4");
}

/**
We adapt according to the error on the embedded geometry, velocity and
tracer fields. */
#if DOUBLE_EMBED
event adapt (i+=2) {
  adapt_wavelet ({cs,u,u2,f}, (double[]){1e-2,3e-2,3e-2,3e-2}, 8, 4);
  t2 += dt
#else
event adapt (i++) {
  adapt_wavelet ({cs,u,f}, (double[]){1e-2,3e-2,3e-2}, 8, 4);
#endif
}

/**
# Future work

* Synchronizing time steps in both phases
* Movement of the boundary must follow the movement of a physical quantity.
Use the velocity field near the boundary to advect a level set function and use
the 0-level set as the boundary for the embedded boundary.
*/
